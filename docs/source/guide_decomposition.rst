Tensor Decomposition
====================

In this section, we will show how to perform tensor decomposition.
Refer to [1]_ for more mathematical details.

In the following sections, we present the mathematical formula of two basic decomposition,
and the data flow graph generated by using tensorboard which is a visual tool offered by tensorflow.
And another example presents formula of pairwise interaction tensor decomposition.


The Tucker tensor decomposition
-------------------------------

.. math::
    \chi = g \times_1 \mathbf{U}\times_2 \mathbf{V}\times_3 \mathbf{W}=\sum_r \sum_s \sum_t g_{rst}\,\mathbf{u}_r \circ \mathbf{v}_s\circ \mathbf{w}_t\equiv \left [ g;\mathbf{U},\mathbf{V},\mathbf{W} \right ]

.. image:: /tensorflow-graph/tucker-HOOI.png

.. code-block:: python

    >>> data_provider = Provider()
    >>> X = np.arange(24).reshape(3, 4, 2)
    >>> data_provider.full_tensor = lambda: tf.constant(X, dtype=tf.float64)
    # HOSVD
    >>> hosvd_env = Environment(data_provider, summary_path='/tmp/tensord')
    >>> hosvd = HOSVD(hosvd_env)
    >>> args = HOSVD.HOSVD_Args(ranks=[2,2,2])
    >>> hosvd.build_model(args)
    >>> hosvd.train()
    # HOOI
    >>> hooi_env = Environment(data_provider, summary_path='/tmp/tensord')
    >>> hooi = HOOI(hooi_env)
    >>> args = hooi.HOOI_Args(ranks=[2, 2, 2], validation_internal=1)
    >>> hooi.build_model(args)
    >>> hooi.train(5)



The CANDECOMP/PARAFAC (CP) tensor decomposition
-----------------------------------------------

.. math::
    \mathcal{X} = \sum_{r}\lambda_{r} \mathbf{u}_{r}\circ \mathbf{v}_{r}\circ \mathbf{w}_{r}\equiv \left [\lambda;\mathbf{U},\mathbf{V},{\mathbf{W}}\right]

.. image:: /tensorflow-graph/cp.png

.. code-block:: python

    >>> data_provider = Provider()
    >>> X = np.arange(24).reshape(3, 4, 2)
    >>> data_provider.full_tensor = lambda: tf.constant(X, dtype=tf.float64)
    >>> env = Environment(data_provider, summary_path='/tmp/tensord')
    >>> cp = CP_ALS(env)
    >>> args = CP_ALS.CP_Args(rank=2, validation_internal=1000)
    >>> cp.build_model(args)
    >>> cp.train(10000)
    >>> print(cp.full - X)



The non-CANDECOMP/PARAFAC (non-CP) tensor decomposition
-------------------------------------------------------

.. image:: /tensorflow-graph/ncp.png

.. code-block:: python

    >>> data_provider = Provider()
    >>> X = np.arange(24).reshape(2, 3, 4)
    >>> data_provider.full_tensor = lambda: tf.constant(X, dtype=tf.float64)
    >>> env = Environment(data_provider, summary_path='/tmp/tensord')
    >>> ncp = NCP(env)
    >>> args = NCP.NCP_Args(rank=2, validation_internal=1)
    >>> ncp.build_model(args)
    >>> ncp.train(500)
    >>> print(ncp.full - X)



The non-tucker tensor decomposition
-----------------------------------

.. image:: /tensorflow-graph/ntucker_core-update.png

.. image:: /tensorflow-graph/ntucker_factor-update.png

.. code-block:: python

    >>> data_provider = Provider()
    # X = np.arange(24).reshape(3, 4, 2)
    >>> X = gen_test_tensor([3, 4, 5], 3)
    >>> data_provider.full_tensor = lambda: tf.constant(X, dtype=tf.float64)
    >>> env = Environment(data_provider, summary_path='/tmp/tensord')
    >>> ntucker = NTUCKER_ALS(env)
    >>> args = NTUCKER_ALS.NTUCKER_Args(ranks=[2, 2, 2], validation_internal=1)
    >>> ntucker.build_model(args)
    >>> ntucker.train(100)
    >>> print(ntucker.full - X)



The example:Pairweise interaciton Tensor Decomposition
------------------------------------------------------

    Formally, pairwise interaction tensor assumes that each entry $T_{ijk}$ of a tensor :math:`\mathcal{T}` of size :math:`n_1 \times n_2\times n_3` is given by following:

.. math::
    T_{ijk}=\left \langle \mathbf{u}_{i}^{\left ( a \right )},\mathbf{v}_{j}^{\left ( a \right )} \right \rangle+\left \langle \mathbf{u}_{j}^{\left ( b \right )},\mathbf{v}_{k}^{\left ( b \right )} \right \rangle+\left \langle \mathbf{u}_{k}^{\left ( c \right )},\mathbf{v}_{i}^{\left ( c \right )} \right \rangle,\mathrm{for\,all}\left ( i,j,k \right )\in \left [ n_1 \right ]\times  \left [ n_2 \right ] \times \left [ n_3 \right ]


The pairwise vectors in this formula are :math:`r_1, r_2, r_3` dimensions:

.. math::
    \left \{ \mathbf{u}_i^{\left \{a \right \}} \right \}_{i\in \left [ n_1 \right ]} , \left \{ \mathbf{v}_j^{\left \{a \right \}} \right \}_{j\in \left [ n_2 \right ]}

    \left \{ \mathbf{u}_j^{\left \{b \right \}} \right \}_{j\in \left [ n_2 \right ]} , \left \{ \mathbf{v}_k^{\left \{b \right \}} \right \}_{k\in \left [ n_3 \right ]}

    \left \{ \mathbf{u}_k^{\left \{c \right \}} \right \}_{k\in \left [ n_3 \right ]} , \left \{ \mathbf{v}_i^{\left \{c \right \}} \right \}_{i\in \left [ n_1 \right ]}

.. code-block:: python

    >>> data_provider = Provider()
    >>> data_provider.full_tensor = lambda: tf.constant(np.random.rand(50, 50, 8)*10, dtype=tf.float32)
    >>> pitf_np_env = Environment(data_provider, summary_path='/tmp/tensord')
    >>> pitf_np = PITF_np(pitf_np_env)
    >>> sess_t = pitf_np_env.sess
    >>> init_op = tf.global_variables_initializer()
    >>> sess_t.run(init_op)
    >>> tensor = pitf_np_env.full_data().eval(session=sess_t)
    >>> args = PITF_np.PITF_np_Args(rank=5, delt=0.8, tao=12, sample_num=100, validation_internal=1, verbose=False, steps=500)
    >>> y, X_t, Y_t, Z_t, Ef_t, If_t, Rf_t = pitf_np.exact_recovery(args, tensor)
    >>> y = tf.convert_to_tensor(y)
    >>> X = tf.convert_to_tensor(X_t)
    >>> Y = tf.convert_to_tensor(Y_t)
    >>> Z = tf.convert_to_tensor(Z_t)
    >>> Ef = tf.convert_to_tensor(Ef_t)
    >>> If = tf.convert_to_tensor(If_t)
    >>> Rf = tf.convert_to_tensor(Rf_t)



Specific details can refer to the paper [2]_  "Exact and Stable Recovery of Pairwise Interaction Tensors, NIPS 2013".



import of test cp decomposition
-------------------------------

.. code-block:: python

    >>> from tensorD.factorization.env import Environment
    >>> from tensorD.factorization.cp import CP_ALS
    >>> from tensorD.factorization.tucker import *
    >>> from tensorD.dataproc.provider import Provider



import of test tucker decomposition
-----------------------------------

.. code-block:: python

    >>> from numpy.random import rand
    >>> from tensorD.factorization.env import Environment
    >>> from tensorD.dataproc.provider import Provider
    >>> from tensorD.factorization.tucker import HOSVD
    >>> from tensorD.factorization.tucker import HOOI



import of test non-tucker decomposition
---------------------------------------

.. code-block:: python

    >>> from tensorD.factorization.env import Environment
    >>> from tensorD.dataproc.provider import Provider
    >>> from tensorD.factorization.ntucker import NTUCKER_ALS
    >>> from tensorD.DataBag import  *



import of test non-cp decomposition
-----------------------------------

.. code-block:: python

    >>> from tensorD.factorization.env import Environment
    >>> from tensorD.factorization.ncp import NCP
    >>> from tensorD.dataproc.provider import Provider
    >>> from tensorD.DataBag import *



import of test pairwise interaction decomposition
-------------------------------------------------

.. code-block:: python

    >>> from tensorD.factorization.pitf_numpy import PITF_np
    >>> from tensorD.factorization.tucker import *
    >>> from tensorD.dataproc.provider import Provider



tips
----
    The test files include in the project.

    The images shown above can clearly see the decomposition process and relationship between each step in decomposition algorithm.



References
----------
.. [1] Tamara G. Kolda and Brett W. Bader, "Tensor Decompositions and Applications",
       SIAM REVIEW, vol. 51, n. 3, pp. 455-500, 2009.

.. [2] Chen, S., Lyu, M. R., King, I., & Xu, Z. (2013). Exact and stable recovery of pairwise interaction tensors.
       In Advances in Neural Information Processing Systems (pp. 1691-1699).
